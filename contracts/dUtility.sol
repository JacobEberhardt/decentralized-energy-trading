/*
DO NOT EDIT THIS FILE!
It is generated by zokrates-code/zoKratesCodeGenerator.js
Edit the template there instead.
*/
pragma solidity >=0.5.0 <0.6.0;

import "./interfaces/IdUtility.sol";
import "./interfaces/IVerifier.sol";
import "./Mortal.sol";

/**
 * @title Utility onchain settlement verifier.
 * @dev Inherits from IdUtility. This approach is analoguous to UtilityBase.sol but with
 * private energy state changes.
 */
contract dUtility is Mortal, IdUtility {

  struct Household {
    // Hashes of (deltaEnergy)
    bytes32 renewableEnergy;
    bytes32 nonRenewableEnergy;
    bytes32 afterNettingDelta;
  }

  uint lastInputIndex = 0;
  uint nonZeroHashes = 0;

  // mapping of all households, by billing period and address
  mapping(uint256 => mapping(address => Household)) households;

  // mapping of all households that are initialized
  mapping(address => bool) householdsInitialized;

  modifier onlyHousehold(address _household) {
    require(msg.sender == _household, "No permission to access. Only household may access itself.");
    _;
  }

  modifier householdExists(address _household) {
    require(householdsInitialized[_household], "Household does not exist.");
    _;
  }

  uint256[] public transfers;

  IVerifier private verifier;

  /** Timestamp of submission deadline of billing period 0. */
  uint submissionDeadlineBillingEpoch;
  /** Duration of one billing period, in seconds. */
  uint billingInterval;

  /**
   * Check that the deadline for meter reading submissions
   * of the given billing period has not passed yet.
   */
  modifier beforeSubmissionDeadline(uint256 billingPeriod) {
    uint256 deadline = submissionDeadlineBillingEpoch + billingInterval * billingPeriod;
    require(now <= deadline, "Meter reading submission deadline already passed for that billing period.");
    _;
  }

  /**
   * Check that the deadline for meter reading submissions
   * of the given billing period has not passed yet.
   */
  function configureSubmissionDeadline(
    uint _submissionDeadlineBillingEpoch,
    uint _billingInterval
  ) external onlyOwner() override returns (bool) {
    submissionDeadlineBillingEpoch = _submissionDeadlineBillingEpoch;
    billingInterval = _billingInterval;
    return true;
  }

  /**
   * @dev Create a household with address _household to track energy production and consumption.
   * Emits NewHousehold when household was added successfully.
   * @param _household address of the household
   * @return success bool if household does not already exists, should only be called by some authority
   */
  function addHousehold(address _household) external onlyOwner() returns (bool) {
    return _addHousehold(_household);
  }

  /**
   * @dev Get energy properties of _household.
   * Used during testing.
   * @param _household address of the household
   * @return Household stats (initialized,
   *                          renewableEnergy,
   *                          nonRenewableEnergy)
   *          of _household if _household exists
   */
  function getHousehold(uint256 billingPeriod, address _household) external view householdExists(_household) returns (bool, bytes32, bytes32) {
    bool initialized = householdsInitialized[_household];
    Household memory hh = households[billingPeriod][_household];
    return (
      initialized,
      hh.renewableEnergy,
      hh.nonRenewableEnergy
    );
  }

  /**
   * @dev Get afterNettingHash of households.
   * @param _household address of the household
   * @return Household stats (afterNettingDelta) of _household if _household exists
   */
  function getHouseholdAfterNettingHash(uint256 billingPeriod, address _household) external view householdExists(_household) returns (bytes32) {
    Household memory hh = households[billingPeriod][_household];
    return hh.afterNettingDelta;
  }

  /**
   * @dev Removes a household.
   * @param _household address of the household
   * @return success bool if household does not already exists, should only be called by some authority
   */
  function removeHousehold(address _household) external onlyOwner() householdExists(_household) returns (bool) {
    delete householdsInitialized[_household];
    // We don't remove the household from the billing periods it participated in.
    // It will stay there until these billing periods time out.
  }

  /**
   * @dev Sets the address of a ZoKrates verifier contract.
   * @param _verifier address of a deployed ZoKrates verifier contract
   */
  function setVerifier(address _verifier) external onlyOwner() returns (bool) {
    verifier = IVerifier(_verifier);
    return true;
  }

   /**
   * @dev Returns next non-zero hash in concatinated format and counts number of nonZero hashes that are needed for later check
   * @param hashes array of hashes
   * @return next concatinated hash
   */
  function _concatNextHash(uint256[8] memory hashes) private returns (bytes32){
    bytes32 res;
    while(lastInputIndex < hashes.length / 2){
      // This assumes that if the first half of the hash is all zero's the second will aswell.
      // Not sure if saved gas (because we check only one part of the hash) is worth the risk of getting a hash that starts with 32 zeros and netting failing
      if(hashes[lastInputIndex] != 0){
        res = bytes32(uint256(hashes[lastInputIndex] << 128 | hashes[lastInputIndex + 1]));
        ++nonZeroHashes;
        lastInputIndex += 2;
        break;
      }
      lastInputIndex += 2;
    }
    return res;
  }

  /**
   * @dev Verifies netting by using ZoKrates verifier contract.
   * Emits ??? when netting could be verified
   */
  function _verifyNetting(
    uint256[2] memory _a,
    uint256[2][2] memory _b,
    uint256[2] memory _c,
    uint256[8] memory _input) private returns (bool success) {
    success = verifier.verifyTx(_a, _b, _c, _input);
    if (success) {
      uint256 record = block.number;
      transfers.push(record);
    }
  }

  /**
   * @dev Validates the equality of the given households and their energy hashes against
   * dUtility's own recorded energy hashes (that the household server sent).
   * Throws when _householdAddrs and _householdEnergyHashes length are not equal.
   * Throws when an energy change hash mismatch has been found.
   * @param _householdAddrs array of household addresses to be checked.
   * @param _inputs array of the corresponding energy hashes.
   * @return true, iff, all given household energy hashes are mathes with the recorded energy hashes.
   */
  function _checkHashes(
    uint256 billingPeriod,
    address[] memory _householdAddrs,
    uint256[8] memory _inputs
  ) private returns (bool) {
    lastInputIndex = 0;
    nonZeroHashes = 0;
    uint numberOfInputHashes = _inputs.length / 2;
    mapping(address => Household) storage householdsInPeriod = households[billingPeriod];
    for(uint256 i = 0; i < _householdAddrs.length; ++i) {
      address addr = _householdAddrs[i];
      bytes32 energyHash = _concatNextHash(_inputs);

      require(householdsInPeriod[addr].renewableEnergy == energyHash, "Household energy hash mismatch.");
      _updateAfterNettingDelta(billingPeriod, addr, [_inputs[(lastInputIndex + numberOfInputHashes - 2)], _inputs[(lastInputIndex + numberOfInputHashes - 1)]]);
    }
    require(_householdAddrs.length == nonZeroHashes, "Number of Household mismatch with nonZeorHashes");
    return true;
  }

  function checkNetting(
    uint256 billingPeriod,
    address[] calldata _householdAddrs,
    uint256[2] calldata _a,
    uint256[2][2] calldata _b,
    uint256[2] calldata _c,
    uint256[8] calldata _input
    ) external returns (bool){
    // Ensure that all households that reported meter_delta !=0 in the netting reported are represented in both, addresslist and hashlist sent to SC
    // require address.len == hash_not_0.len / 2 where hash_not_0 is hashes recreated from _input that are not 0.
    // To evaluate the _input hashes, we need to loop through the addresslist provided with the proof and check whether the SC hash registry has values
    require(_checkHashes(billingPeriod, _householdAddrs, _input) == true, "Hashes not matching!");
    require(_verifyNetting(_a, _b, _c, _input) == true, "Netting proof failed!");
    emit NettingSuccess(billingPeriod);
    return true;
  }

  /**
   * @return uint256 length of all successfully verified settlements
   */
  function getTransfersLength() external view returns (uint256) {
    return transfers.length;
  }

  /**
   * @dev Updates a household's renewable energy state calling _updateEnergy
   * @param _household address of the household
   * @param _deltaEnergy bytes32 hash of (delta+nonce+senderAddr)
   * @return success bool returns true, if function was called successfully
   */
  function updateRenewableEnergy(
    uint256 billingPeriod,
    address _household,
    bytes32 _deltaEnergy)
  external
  onlyHousehold(_household)
  returns (bool) {
    _updateEnergy(billingPeriod, _household, _deltaEnergy, true);
  }

  /**
   * @dev Updates a household's non-renewable energy state calling _updateEnergy
   * @param _household address of the household
   * @param _deltaEnergy bytes32 hash of (delta+nonce+senderAddr)
   * @return success bool returns true, if function was called successfully
   */
  function updateNonRenewableEnergy(
    uint256 billingPeriod,
    address _household,
    bytes32 _deltaEnergy)
  external onlyHousehold(_household)
  returns (bool) {
    _updateEnergy(billingPeriod, _household, _deltaEnergy, false);
  }

  /**
   * @dev Updates a household's energy state
   * @param _household address of the household
   * @param _deltaEnergy bytes32 hash of (delta+nonce+senderAddr)
   * @param _isRenewable bool indicates whether said energy is renewable or non-renewable
   * @return success bool returns true, if function was called successfully
   */
  function _updateEnergy(
    uint256 billingPeriod,
    address _household,
    bytes32 _deltaEnergy,
    bool _isRenewable)
  internal
  householdExists(_household)
  beforeSubmissionDeadline(billingPeriod)
  returns (bool) {
    Household storage hh = households[billingPeriod][_household];
    if (_isRenewable) {
      hh.renewableEnergy = _deltaEnergy;
      emit RenewableEnergyChanged(billingPeriod, _household, _deltaEnergy);
    } else {
      hh.nonRenewableEnergy = _deltaEnergy;
      emit NonRenewableEnergyChanged(billingPeriod, _household, _deltaEnergy);
    }
    return true;
  }

  /**
   * @dev Updates a household's energy state
   * @param _household address of the household
   * @param _afterNettingDelta both halfs of post netting delta hash
   * @return success bool returns true, if function was called successfully
   */
  function _updateAfterNettingDelta(uint256 billingPeriod, address _household, uint256[2] memory _afterNettingDelta)
  internal
  householdExists(_household)
  {
    Household storage hh = households[billingPeriod][_household];
    hh.afterNettingDelta = bytes32(uint256(_afterNettingDelta[0] << 128 | _afterNettingDelta[1]));
  }

  /**
   * @dev see UtilityBase.addHousehold
   * @param _household address of household
   * @return success bool
   */
  function _addHousehold(address _household) internal onlyOwner returns (bool) {
    require(!householdsInitialized[_household], "Household already exists.");

    // add new household to mapping
    householdsInitialized[_household] = true;

    emit NewHousehold(_household);
    return true;
  }

  function _setVerifier(address _verifier) internal returns (bool) {
    verifier = IVerifier(_verifier);
    return true;
  }
}
