// Calculate new energy state for households
// @param {field[2]} householdList
// @param {field[2]} householdListAmountOfEnergy
// @returns {field[2]} updatedHouseholdList
def calculateEnergyForHouseholds(field[2] householdList, field[2] householdListAmountOfEnergy) -> (field[2]):
  field[2] updatedHouseholdList = [0, 0]
  for field i in 0..1 do
    updatedHouseholdList[i] = householdList[i] - householdListAmountOfEnergy[i]
  endfor
  return updatedHouseholdList

// Calculate the proportional amount of energy for household on energy
// @param {field[2]} householdListProportionOnEnergy
// @param {field} energy
// @returns {field[2]} householdListAmountOfEnergy
def amountOf(field[2] householdListProportionOnEnergy, field energy) -> (field[2]):
  field[2] householdListAmountOfEnergy = [0, 0]
  for field i in 0..1 do
    householdListAmountOfEnergy[i] = (energy * householdListProportionOnEnergy[i]) / 100
  endfor
  return householdListAmountOfEnergy

// Calculate proportion of household on energy
// @param {field[2]} householdList
// @param {field} energy
// @returns {field[2]} householdListProportionOnEnergy
def proportionalDistribution(field[2] householdList, field energy) -> (field[2]):
  field[2] householdListProportionOnEnergy = [0, 0]
  for field i in 0..1 do
    householdListProportionOnEnergy[i] = (100 * householdList[i]) / energy
  endfor
  return householdListProportionOnEnergy

// Simply return householdListWithEnergy[0] + householdListWithEnergy[1] and householdListNoEnergy[0] + householdListNoEnergy[1]
// @param {field[2]} householdListWithEnergy
// @param {field[2]} householdListNoEnergy
// @returns {field, field} availableEnergy, neededEnergy
def totalEnergyProportion(field[2] householdListWithEnergy, field[2] householdListNoEnergy) -> (field, field):
  field availableEnergy = 0
  field neededEnergy = 0
  for field i in 0..1 do
    availableEnergy = availableEnergy + householdListWithEnergy[i]
    neededEnergy = neededEnergy + householdListNoEnergy[i]
  endfor
  return availableEnergy, neededEnergy

// Settlement function for netting
// Assume n = 4 households, where |householdListWithEnergy| = 2 and |householdListNoEnergy| = 2
// Households with produce-consume = 0 are not part of the settlement
// @param {private field[2]} householdListWithEnergy
// Index represents household and householdListWithEnergy[index] := produce-consume > 0 
// @param {private field[2]} householdListNoEnergy
// Index represents household and householdListNoEnergy[index] := produce-consume < 0 
// @returns {field[2], field[2]} 
// return value needs to be hashed with sha256 if we do not want to expose the netting results
def main(private field[2] householdListWithEnergy, private field[2] householdListNoEnergy) -> (field[2], field[2]):
  availableEnergy, neededEnergy = totalEnergyProportion(householdListWithEnergy, householdListNoEnergy)
  
  propDistA = proportionalDistribution(householdListWithEnergy, availableEnergy)
  propDistB = proportionalDistribution(householdListNoEnergy, neededEnergy)
  field[2] householdListProportionOnEnergy = if (availableEnergy > neededEnergy) then propDistA else propDistB fi

  amountA = amountOf(householdListProportionOnEnergy, neededEnergy)
  amountB = amountOf(householdListProportionOnEnergy, availableEnergy)
  field[2] householdListAmountOfEnergy = if (availableEnergy > neededEnergy) then amountA else amountB fi
  
  calcEnergyA = calculateEnergyForHouseholds(householdListWithEnergy, householdListAmountOfEnergy)
  calcEnergyB = calculateEnergyForHouseholds(householdListNoEnergy, householdListAmountOfEnergy)
  field[2] updatedHouseholdList = if (availableEnergy > neededEnergy) then calcEnergyA else calcEnergyB fi

  field[2] updatedhouseholdListWithEnergy = if (availableEnergy > neededEnergy) then updatedHouseholdList else [0,0] fi

  field[2] updatedhouseholdListNoEnergy = if (availableEnergy > neededEnergy) then [0,0] else updatedHouseholdList fi

  return updatedhouseholdListWithEnergy, updatedhouseholdListNoEnergy
