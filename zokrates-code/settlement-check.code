// Correctness, no energy is generated, no energy has dissolved
// Fairness, proportion on available/needed energy is calculated; proportional distribution

// Second approach

import "hashes/sha256/512bitPacked.code" as sha256packed

def totalEnergy(field[2] hh) -> (field):
  field energy = 0
  for field i in 0..1 do
    energy = energy + hh[i]
  endfor
  return energy

def deltaNet(field[2] hh, field[2] hhNet) -> (field):
  field delta = 0
  for field i in 0..1 do
    delta = delta + (hh[i] - hhNet[i])
  endfor
  return delta

def validateSolution(field[2] hh, field[2] hhNet) -> (field):
  field errorCounter = 0

  for field i in 0..1 do
    // Netting should NEVER make things worse, i.e., giving a demanding household more demand or
    // allocating a producing household more energy
    // There is more space for stricter invariants
    errorCounter = errorCounter + if hhNet[i] > hh[i] then 1 else 0 fi
  endfor

  return errorCounter

// Returns 1, when netting result is "correct and fair", 0 otherwise.
def main(private field[2] hhWithEnergy, private field[2] hhNoEnergy, private field[2] hhWithEnergyNet, private field[2] hhNoEnergyNet) -> (field[2]):
  deltaNetWithEnergy = deltaNet(hhWithEnergy, hhWithEnergyNet)
  deltaNetNoEnergy = deltaNet(hhNoEnergy, hhNoEnergyNet)
  
  // Correctness check, does this suffice?
  // Energy system stays the same
  deltaNetWithEnergy == deltaNetNoEnergy

  // Invariants
  0 == validateSolution(hhWithEnergy, hhWithEnergyNet)
  0 == validateSolution(hhNoEnergy, hhNoEnergyNet)
  
  // When we have private inputs, we are apparently required to return something that depend on those inputs
  // This is my observation, maybe there is a workaround...
  field sum = hhWithEnergy[0] + hhWithEnergy[1] + hhNoEnergy[0] + hhNoEnergy[1] + hhWithEnergyNet[0] + hhWithEnergyNet[1] + hhNoEnergyNet[0] + hhNoEnergyNet[1]
  h = sha256packed([sum, 0, 0, 0])

  return h
