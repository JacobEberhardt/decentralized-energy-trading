// Correctness: After a settlement the total energy balance remains the same, i.e. no energy is generated and no energy has dissolved within the settlement.
// We introduce different fairness assumptions: Given households hhWithEnergy (produce-consume > 0) and households hhNoEnergy (produce-consume < 0 ), a settlement is fair,
// - if a household transfers/ receives the amount of energy corresponding to its proportion on total available/ needed energy 
//   depending on the total energy balance in the system (proportional fairness). This would be the corresponding fairness assumption to the implemented settlement algorithm.
//   Therefore, this fairness assumption can be implemented by following a naive approach of calculating the settlement within ZoKrates and compare input with calculated settlement results.
// - given some threshold h (e.g. percentage on energy), if a household transfers/ receives atleast h of its available/ needed energy (threshold fairness).
// - if a household of hhWithEnergy (with energy balance e_b before settlement and energy balance e_a after) transfers "some" energy such that e_b < e_a while e_a >= 0
//   and a household of hhNoEnergy (with energy balance e_b before settlement and energy balance e_a after) receives "some" energy such that e_b > e_a while e_a <= 0 (weak fairness). 
//   This fairness assumption would be weak but fits different settlement algorithms.
// For reasons of simplicity and mobility, we follow the approach of weak fairness.


import "hashes/sha256/512bitPacked.code" as sha256packed

// Simply return hh[0] + hh[1] for any array of households.
// @param {field[2]} hh
// @returns {field} energy of provided households
def energyOf(field[2] hh) -> (field):
  field energy = 0
  for field i in 0..1 do
    energy = energy + hh[i]
  endfor
  return energy

// Returns total energy balance of the system. Remember, this balance can be available or needed energy.
// @param {field[2]} hhWithEnergy
// @param {field[2]} hhNoEnergy
// @returns {field} totalEnergy
def calculateTotalEnergy(field[2] hhWithEnergy, field[2] hhNoEnergy) -> (field):
  availableEnergy = energyOf(hhWithEnergy)
  neededEnergy = energyOf(hhNoEnergy)

  field totalEnergy = if (availableEnergy > neededEnergy) then (availableEnergy - neededEnergy) else (neededEnergy - availableEnergy) fi

  return totalEnergy

// Returns sum of deltas between hh and hhNet
// @param {field[2]} hh
// @param {field[2]} hhNet
// @returns {field} delta
def deltaNet(field[2] hh, field[2] hhNet) -> (field):
  field delta = 0
  for field i in 0..1 do
    delta = delta + (hh[i] - hhNet[i])
  endfor
  return delta

// Returns errorCounter. Implements weak fairness invariant
// @param {field[2]} hh
// @param {field[2]} hhNet
// @returns {field} errorCounter
def validateFairness(field[2] hh, field[2] hhNet) -> (field):
  field errorCounter = 0

  for field i in 0..1 do
    // Netting should NEVER make things worse, i.e., giving a demanding household more demand or allocating a producing household more energy
    errorCounter = errorCounter + if hhNet[i] > hh[i] then 1 else 0 fi
  endfor

  return errorCounter

// Validates the zero-net property (one set of household will be 0 (up to an epislon error) after netting)
// Is valid, only if returns 0.
// @param {field[2]} household party (either needing or having energy)
// @param epsilon the error tolerance value
def validateZeroNet(field[2] hh, field epsilon) -> (field):
  field errorCounter = 0
  for field i in 0..1 do
    errorCounter = errorCounter + if hh[i] > epsilon then 1 else 0 fi
  endfor
  
  return errorCounter

def sum(field[2] hh) -> (field):
  field s = 0
  for field i in 0..1 do
    s = s + hh[i]
  endfor
  
  return s


// Returns sha256packed hash if settlement (netting) result is correct.
// Checks for correctness and weak fairness.
// Assume n = 4 households, where |householdListWithEnergy| = 2 and |householdListNoEnergy| = 2
// Before settlement, households with produce-consume = 0 are not part of the settlement
// @param {private field[2]} hhWithEnergy before settlement
// Index represents household and hhWithEnergy[index] := produce-consume > 0 
// @param {private field[2]} hhNoEnergy before settlement
// Index represents household and hhNoEnergy[index] := produce-consume < 0 
// @param {private field[2]} hhWithEnergyNet after settlement
// Index represents household and hhWithEnergyNet[index] := produce-consume > 0 
// @param {private field[2]} hhNoEnergyNet after settlement
// Index represents household and hhNoEnergyNet[index] := produce-consume < 0
// @param {private field[8]} hhWithEnergyPacked Packed inputs energy + nonce + address of hh with energy surplus
// Index 0 to 3 are packed inputs of hh1 with energy surplus
// Index 4 to 7 are packed inputs of hh2 with energy surplus
// @param {private field[8]} hhNoEnergyPacked Packed inputs energy + nonce + address of hh with energy deficit
// Index 0 to 3 are packed inputs of hh1 with energy deficit
// Index 4 to 7 are packed inputs of hh2 with energy deficit
// @returns {field[2], field[2], field[2], field[2]} sha256packed hashes of hhWithEnergyPacked / hhNoEnergyPacked
def main(private field[2] hhWithEnergy, private field[2] hhNoEnergy, private field[2] hhWithEnergyNet, private field[2] hhNoEnergyNet, private field[8] hhWithEnergyPacked, private field[8] hhNoEnergyPacked) -> (field[2], field[2], field[2], field[2]):
  // Correctness: Energy balance in the system stays the same
  totalEnergy = calculateTotalEnergy(hhWithEnergy, hhNoEnergy)
  totalEnergyNet = calculateTotalEnergy(hhWithEnergyNet, hhNoEnergyNet)
  totalEnergy == totalEnergyNet

  // (Strong) Correctness: Transferred energy (deltaNetWithEnergy) is equal to received energy (deltaNetNoEnergy) 
  deltaNetWithEnergy = deltaNet(hhWithEnergy, hhWithEnergyNet)
  deltaNetNoEnergy = deltaNet(hhNoEnergy, hhNoEnergyNet)
  deltaNetWithEnergy == deltaNetNoEnergy

  // Weak fairness
  0 == validateFairness(hhWithEnergy, hhWithEnergyNet)
  0 == validateFairness(hhNoEnergy, hhNoEnergyNet)

  // One party zero-net energy
  field sumWithEnergy = sum(hhWithEnergyNet)
  field sumNoEnergy = sum(hhNoEnergyNet)
  field[2] zeroNetParty = if sumWithEnergy <= sumNoEnergy then hhWithEnergyNet else hhNoEnergyNet fi
  0 == validateZeroNet(zeroNetParty, 15) // Can make epsilon more accurate in the future
  
  // Return sha256packed hash of energy + nonce + address of each household
  hh1WithEnergyHash = sha256packed([hhWithEnergyPacked[0], hhWithEnergyPacked[1], hhWithEnergyPacked[2], hhWithEnergyPacked[3]])
  hh2WithEnergyHash = sha256packed([hhWithEnergyPacked[4], hhWithEnergyPacked[5], hhWithEnergyPacked[6], hhWithEnergyPacked[7]])
  hh1NoEnergyHash = sha256packed([hhNoEnergyPacked[0], hhNoEnergyPacked[1], hhNoEnergyPacked[2], hhNoEnergyPacked[3]])
  hh2NoEnergyHash = sha256packed([hhNoEnergyPacked[4], hhNoEnergyPacked[5], hhNoEnergyPacked[6], hhNoEnergyPacked[7]])
  

  return hh1WithEnergyHash, hh2WithEnergyHash, hh1NoEnergyHash, hh2NoEnergyHash
