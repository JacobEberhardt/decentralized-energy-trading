// Correctness: After a settlement the total energy balance remains the same, i.e. no energy is generated and no energy has dissolved within the settlement.
// We introduce different fairness assumptions: Given households hhWithEnergy (produce-consume > 0) and households hhNoEnergy (produce-consume < 0 ), a settlement is fair,
// - if a household transfers/ receives the amount of energy corresponding to its proportion on total available/ needed energy 
//   depending on the total energy balance in the system (proportional fairness). This would be the corresponding fairness assumption to the implemented settlement algorithm.
//   Therefore, this fairness assumption can be implemented by following a naive approach of calculating the settlement within ZoKrates and compare input with calculated settlement results.
// - given some threshold h (e.g. percentage on energy), if a household transfers/ receives atleast h of its available/ needed energy (threshold fairness).
// - if a household of hhWithEnergy (with energy balance e_b before settlement and energy balance e_a after) transfers "some" energy such that e_b < e_a while e_a >= 0
//   and a household of hhNoEnergy (with energy balance e_b before settlement and energy balance e_a after) receives "some" energy such that e_b > e_a while e_a <= 0 (weak fairness). 
//   This fairness assumption would be weak but fits different settlement algorithms.
// For reasons of simplicity and mobility, we follow the approach of weak fairness.


import "hashes/sha256/512bitPacked.code" as sha256packed

def energyOf(field[2] hh) -> (field):
  field energy = 0;
  for field i in 0..1 do
    energy = energy + hh[i]
  endfor
  return energy

def calculateTotalEnergy(field[2] hhWithEnergy, field[2] hhNoEnergy) -> (field):
  availableEnergy = energyOf(hhWithEnergy)
  neededEnergy = energyOf(hhNoEnergy)

  field totalEnergy = if (availableEnergy > neededEnergy) then (availableEnergy - neededEnergy) else (neededEnergy - availableEnergy) fi

  return totalEnergy

def deltaNet(field[2] hh, field[2] hhNet) -> (field):
  field delta = 0
  for field i in 0..1 do
    delta = delta + (hh[i] - hhNet[i])
  endfor
  return delta

def validateFairness(field[2] hh, field[2] hhNet) -> (field):
  field errorCounter = 0

  for field i in 0..1 do
    // Netting should NEVER make things worse, i.e., giving a demanding household more demand or allocating a producing household more energy
    errorCounter = errorCounter + if hhNet[i] > hh[i] then 1 else 0 fi
  endfor

  return errorCounter

// Returns sha256packed hash if settlement (netting) result is correct.
// Checks for correctness and weak fairness.
def main(private field[2] hhWithEnergy, private field[2] hhNoEnergy, private field[2] hhWithEnergyNet, private field[2] hhNoEnergyNet) -> (field[2]):
  // Correctness: Energy balance in the system stays the same
  totalEnergy = calculateTotalEnergy(hhWithEnergy, hhNoEnergy)
  totalEnergyNet = calculateTotalEnergy(hhWithEnergyNet, hhNoEnergyNet)
  totalEnergy == totalEnergyNet

  // (Strong) Correctness: Transferred energy (deltaNetWithEnergy) is equal to received energy (deltaNetNoEnergy) 
  deltaNetWithEnergy = deltaNet(hhWithEnergy, hhWithEnergyNet)
  deltaNetNoEnergy = deltaNet(hhNoEnergy, hhNoEnergyNet)
  deltaNetWithEnergy == deltaNetNoEnergy

  // Weak fairness
  0 == validateFairness(hhWithEnergy, hhWithEnergyNet)
  0 == validateFairness(hhNoEnergy, hhNoEnergyNet)
  
  // Return sha256packed hash that depends on inputs
  field sum = hhWithEnergy[0] + hhWithEnergy[1] + hhNoEnergy[0] + hhNoEnergy[1] + hhWithEnergyNet[0] + hhWithEnergyNet[1] + hhNoEnergyNet[0] + hhNoEnergyNet[1]
  h = sha256packed([sum, 0, 0, 0])

  return h
